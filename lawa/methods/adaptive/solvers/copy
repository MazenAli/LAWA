#ifndef LAWA_METHODS_ADAPTIVE_SOLVERS_RANK1ALS_TCC
#define LAWA_METHODS_ADAPTIVE_SOLVERS_RANK1ALS_TCC 1

#include <iostream>
#include <cmath>
#include <cassert>
#include <htucker/htucker.h>
#include <flens/flens.cxx>
#include <lawa/methods/adaptive/solvers/cg.h>
#include <lawa/methods/adaptive/solvers/splitting.h>
#include <lawa/preconditioners/preconditioners1d/H1normpreconditioner1d.h>

namespace lawa
{

template <typename Optype, typename T, typename Basis>
unsigned
rank1als_sym(       Sepop<Optype>&                      A,
                    HTCoefficients<T, Basis>&           x,
              const HTCoefficients<T, Basis>&           b,
              const std::vector<IndexSet<Index1D> >&    Lambda,
                    T&                                  residual,
              const bool                                orthog,
              const T                                   tol,
              const unsigned                            max_sweep,
              const T                                   tol_cg,
              const unsigned                            maxit_cg)
{
    typedef typename flens::GeMatrix
                    <flens::FullStorage<T, cxxblas::ColMajor> >     Matrix;
    typedef typename htucker::HTuckerTree<T>                        HTTree;
    typedef HTCoefficients<T, Basis>                                HTCoeff;

    /* Initial residual */
    HTCoeff Ax;
    T nrmb = nrm2(const_cast<HTCoeff&>(b));

    Ax         = eval(A, x, Lambda, Lambda);
    HTTree res = b.tree()-Ax.tree();
    res.orthogonalize();
    residual   = res.L2normorthogonal()/nrmb;
    #ifdef VERBOSE
        std::cout << "rank1als_sym: Sweep " << 0 << ", leaf " << 0
                  << ", residual = " << residual << "\n";
    #endif
    if (residual<=tol) return 0;

    /* ALS sweeps */
    for (unsigned sweep=1; sweep<=max_sweep; ++sweep) {
        for (unsigned j=1; j<=A.dim(); ++j) {
            /* Compute projection */
            Matrix Pj  = projection(Ax.tree(), x.tree(), j);
            Matrix B   = contract(b.tree(), x.tree(), j);

            /* CG solve on leaf*/
            htucker::DimensionIndex idx(1);
            idx[0]           = j;
            Matrix   xk      = extract(x.tree(), idx);
            T res_cg;
            unsigned it      = cg(A, xk, B, Pj, x, j,
                                  Lambda[j-1], res_cg, tol_cg, maxit_cg);
            #ifdef VERBOSE
                std::cout << "rank1als_sym: CG required " << it
                          << " iterations to reach "
                          << res_cg << "\n";
            #endif

            /* Update x */
            insert(x.tree(), xk, idx);
            if (orthog) x.tree().orthogonalize();

            /* Full residual */
            Ax         = eval(A, x, Lambda, Lambda);
            res        = b.tree()-Ax.tree();
            res.orthogonalize();
            residual   = res.L2normorthogonal()/nrmb;
            #ifdef VERBOSE
                std::cout << "rank1als_sym: Sweep " << sweep << ", leaf " << j
                          << ", residual = " << residual << "\n";
            #endif
            if (residual<=tol) return sweep;
        }
    }

    std::cerr << "rank1als_sym: Reached max sweeps " << max_sweep << "\n";
    return max_sweep;
}


template <typename Optype, typename T, typename Basis>
unsigned
rank1als_sym(       Sepop<Optype>&                      A,
                    Sepdiagscal<Basis>&                 S,
                    HTCoefficients<T, Basis>&           x,
              const HTCoefficients<T, Basis>&           b,
              const std::vector<IndexSet<Index1D> >&    Lambda,
                    T&                                  residual,
              const bool                                orthog,
              const T                                   tol,
              const unsigned                            max_sweep,
              const T                                   tol_cg,
              const unsigned                            maxit_cg)
{
    typedef typename flens::GeMatrix
                    <flens::FullStorage<T, cxxblas::ColMajor> >     Matrix;
    typedef typename htucker::HTuckerTree<T>                        HTTree;
    typedef HTCoefficients<T, Basis>                                HTCoeff;

    /* Initial residual */
    HTCoeff Ax, Sb = fixeval_notrunc(S, const_cast<HTCoeff&>(b), Lambda);
    T nrmb = nrm2(Sb);

    Ax         = fixeval_notrunc(S, x, Lambda);
    Ax         = eval(A, Ax, Lambda, Lambda);
    Ax         = fixeval_notrunc(S, Ax, Lambda);
    HTTree res = Sb.tree()-Ax.tree();
    res.orthogonalize();
    residual   = res.L2normorthogonal()/nrmb;
    #ifdef VERBOSE
        std::cout << "rank1als_sym: Sweep " << 0 << ", leaf " << 0
                  << ", residual = " << residual << "\n";
    #endif
    if (residual<=tol) return 0;

    /* ALS sweeps */
    for (unsigned sweep=1; sweep<=max_sweep; ++sweep) {
        for (unsigned j=1; j<=A.dim(); ++j) {
            /* Compute projection */
            Matrix Pj  = projection(Ax.tree(), x.tree(), j);
            Matrix B   = contract(Sb.tree(), x.tree(), j);

            /* CG solve on leaf*/
            htucker::DimensionIndex idx(1);
            idx[0]           = j;
            Matrix   xk      = extract(x.tree(), idx);
            T res_cg;
            unsigned it      = cg(A, S, xk, B, Pj, x, j,
                                  Lambda[j-1], res_cg, tol_cg, maxit_cg);
            #ifdef VERBOSE
                std::cout << "rank1als_sym: CG required " << it
                          << " iterations to reach "
                          << res_cg << "\n";
            #endif

            /* Update x */
            insert(x.tree(), xk, idx);
            if (orthog) x.tree().orthogonalize();

            /* Full residual */
            Ax         = fixeval_notrunc(S, x, Lambda);
            Ax         = eval(A, Ax, Lambda, Lambda);
            Ax         = fixeval_notrunc(S, Ax, Lambda);
            res        = Sb.tree()-Ax.tree();
            res.orthogonalize();
            residual   = res.L2normorthogonal()/nrmb;
            #ifdef VERBOSE
                std::cout << "rank1als_sym: Sweep " << sweep << ", leaf " << j
                          << ", residual = " << residual << "\n";
            #endif
            if (residual<=tol) return sweep;
        }
    }

    std::cerr << "rank1als_sym: Reached max sweeps " << max_sweep << "\n";
    return max_sweep;
}


template <typename Optype, typename Prec, typename T, typename Basis>
unsigned
rank1als_sym(       Sepop<Optype>&                      A,
                    Prec&                               P,
                    HTCoefficients<T, Basis>&           x,
              const HTCoefficients<T, Basis>&           b,
              const std::vector<IndexSet<Index1D> >&    Lambda,
                    T&                                  residual,
              const bool                                orthog,
              const T                                   tol,
              const unsigned                            max_sweep,
              const T                                   tol_cg,
              const unsigned                            maxit_cg)
{
    typedef typename flens::GeMatrix
                    <flens::FullStorage<T, cxxblas::ColMajor> >     Matrix;
    typedef typename htucker::HTuckerTree<T>                        HTTree;
    typedef HTCoefficients<T, Basis>                                HTCoeff;

    /* Initial residual */
    HTCoeff Ax;
    T nrmb = nrm2(const_cast<HTCoeff&>(b));

    Ax         = eval(A, x, Lambda, Lambda);
    HTTree res = b.tree()-Ax.tree();
    res.orthogonalize();
    residual   = res.L2normorthogonal()/nrmb;
    #ifdef VERBOSE
        std::cout << "rank1als_sym: Sweep " << 0 << ", leaf " << 0
                  << ", residual = " << residual << "\n";
    #endif
    if (residual<=tol) return 0;

    /* ALS sweeps */
    for (unsigned sweep=1; sweep<=max_sweep; ++sweep) {
        for (unsigned j=1; j<=A.dim(); ++j) {
            /* Compute projection */
            Matrix Pj     = projection(Ax.tree(), x.tree(), j);
            Matrix B      = contract(b.tree(), x.tree(), j);

            /* CG solve on leaf*/
            htucker::DimensionIndex idx(1);
            idx[0]           = j;
            Matrix   xk      = extract(x.tree(), idx);
            T res_cg;
            unsigned it      = cg(A, P, xk, B, Pj, x, j,
                                              Lambda[j-1],
                                              res_cg, tol_cg, maxit_cg);
            #ifdef VERBOSE
                std::cout << "rank1als_sym: CG required " << it
                          << " iterations to reach "
                          << res_cg << "\n";
            #endif

            /* Update x */
            insert(x.tree(), xk, idx);
            if (orthog) x.tree().orthogonalize();

            /* Full residual */
            Ax         = eval(A, x, Lambda, Lambda);
            res        = b.tree()-Ax.tree();
            res.orthogonalize();
            residual   = res.L2normorthogonal()/nrmb;
            #ifdef VERBOSE
                std::cout << "rank1als_sym: Sweep " << sweep << ", leaf " << j
                          << ", residual = " << residual << "\n";
            #endif
            if (residual<=tol) return sweep;
        }
    }

    std::cerr << "rank1als_sym: Reached max sweeps " << max_sweep << "\n";
    return max_sweep;
}


template <typename Optype, typename Prec, typename T, typename Basis>
unsigned
precrank1als_sym(       Sepop<Optype>&                      A,
                        Prec&                               P,
                        HTCoefficients<T, Basis>&           x,
                  const HTCoefficients<T, Basis>&           b,
                  const std::vector<IndexSet<Index1D> >&    Lambda,
                        T&                                  residual,
                  const bool                                check_res,
                  const bool                                orthog,
                  const bool                                sw,
                  const T                                   balance,
                  const T                                   tol,
                  const unsigned                            max_sweep,
                  const T                                   tol_cg,
                  const unsigned                            maxit_cg)
{
    typedef typename flens::GeMatrix
                    <flens::FullStorage<T, cxxblas::ColMajor> >     Matrix;
    typedef typename htucker::HTuckerTree<T>                        HTTree;
    typedef HTCoefficients<T, Basis>                                HTCoeff;

    /* Initial residual */
    HTCoeff Ax, Sb(b), xold;
    rank1prec(P, Sb, Lambda);
    T nrmb;

    if (check_res) {
        HTCoeff tmp;
        tmp        = eval(A, x, Lambda, Lambda);
        HTTree res = b.tree()-tmp.tree();
        res.orthogonalize();
        nrmb       = nrm2(const_cast<HTCoeff&>(b));
        residual   = res.L2normorthogonal()/nrmb;
            std::cout << "precrank1als_sym: Sweep " << 0 << ", leaf " << 0
                      << ", residual = " << residual << "\n";
    }

    /* Choose preconditioning */
    auto jmax = maxlevels(Lambda);
    flens::DenseVector<flens::Array<T> > scales(jmax.length());
    for (unsigned j=1; j<=A.dim(); ++j) {
        scales(j) = std::pow(2., 2.*(jmax(j)-x.basis().j0));
    }

    /* ALS sweeps */
    int prec = 2;
    Matrix Pj, B;
    T eps;
    if (sw) {
        Ax  = eval(A, x, Lambda, Lambda);
        Pj  = projection(Ax.tree(), x.tree(), 1);
        eps = Pj(1, 2)/Pj(1, 1);
    }

    if (sw && eps*balance*scales(1)<1.) {
        B    = contract(b.tree(), x.tree(), 1);
        prec = 1;
    } else {
        Ax = eval(A, x, Lambda, Lambda);
        rank1prec(P, Ax, Lambda);
        HTCoeff tmp = x;
        remove_rank1prec(P, tmp, Lambda);
        Pj = projection(Ax.tree(), tmp.tree(), 1);
        B  = contract(Sb.tree(), tmp.tree(), 1);
        B  = remove_prec(P, B, x, 1, Lambda[0]);
        prec = 2;
    }

    for (unsigned sweep=1; sweep<=max_sweep; ++sweep) {
        xold = x;

        for (unsigned j=1; j<=A.dim(); ++j) {
            if (!(sweep==1&&j==1)) {
                HTCoeff tmp;
                /* Compute projection */
                switch (prec) {
                    case 1: {
                        Pj  = projection(Ax.tree(), x.tree(), j);
                        break;
                   }
                    case 2: {
                        tmp = x;
                        remove_rank1prec(P, tmp, Lambda);
                        Pj  = projection(Ax.tree(), tmp.tree(), j);
                        break;
                    }
                }
                    eps = Pj(1, 2)/Pj(1, 1);
                    {
                        HTCoeff Axnonprec = eval(A, x, Lambda, Lambda);
                        auto Pjnonprec = projection(Axnonprec.tree(), x.tree(), j);
                        rank1prec(P, Axnonprec, Lambda);
                        HTCoeff xprec = x;
                        remove_rank1prec(P, xprec, Lambda);
                        auto Pjprec    = projection(Axnonprec.tree(), xprec.tree(), j);
                        T epsnprec = Pjnonprec(1, 2)/Pjnonprec(1, 1);
                        T epsprec  = Pjprec(1, 2)/Pjprec(1, 1);
                        std::cout << "Current epsilon non prec " << epsnprec << std::endl;
                        std::cout << "Current epsilon     prec " << epsprec << std::endl;
                    }
                switch (prec) {
                    case 1: {
                        if (eps*balance*scales(j)<1.) {
                            B    = contract(b.tree(), x.tree(), j);
                            prec = 1;
                        } else {
                            std::cout << "Switch from case 1 to case 2\n";
                            tmp  = x;
                            remove_rank1prec(P, tmp, Lambda);
                            Ax   = eval(A, x, Lambda, Lambda);
                            rank1prec(P, Ax, Lambda);
                            Pj   = projection(Ax.tree(), tmp.tree(), j);
                            B    = contract(Sb.tree(), tmp.tree(), j);
                            B    = remove_prec(P, B, x, j, Lambda[j-1]);
                            prec = 2;
                        }

                        break;
                }
                    case 2: {
                        if (sw && eps*balance*scales(j)<1.) {
                            std::cout << "Switch from case 2 to case 1\n";
                            Pj   = projection(Ax.tree(), x.tree(), j);
                            Ax   = eval(A, x, Lambda, Lambda);
                            B    = contract(b.tree(), x.tree(), j);
                            prec = 1;
                        } else {
                            B    = contract(Sb.tree(), tmp.tree(), j);
                            B    = remove_prec(P, B, x, j, Lambda[j-1]);
                            prec = 2;
                        }

                        break;
                    }
                }
            }

            switch (prec) {
                case 1: {
                    #ifdef VERBOSE
                        std::cout << "precrank1als_sym: Solving the non-prec case\n";
                    #endif
                    /* CG solve on leaf*/
                    htucker::DimensionIndex idx(1);
                    idx[0]           = j;
                    Matrix   xk      = extract(x.tree(), idx);
                    T res_cg;
                    unsigned it      = cg(A, xk, B, Pj, x, j,
                                          Lambda[j-1], res_cg, tol_cg, maxit_cg);

                    #ifdef VERBOSE
                        std::cout << "precrank1als_sym: Sweep " << sweep << ", leaf "
                                  << j << ", CG required " << it
                                  << " iterations to reach "
                                  << res_cg << "\n";
                    #endif

                    /* Update x */
                    insert(x.tree(), xk, idx);
                    if (orthog) x.tree().orthogonalize();

                    break;
                }
                case 2: {
                    #ifdef VERBOSE
                        std::cout << "precrank1als_sym: Solving the prec case\n";
                    #endif
                    /* CG solve on leaf*/
                    htucker::DimensionIndex idx(1);
                    idx[0]       = j;
                    Matrix   xk  = extract(x.tree(), idx);
                    T res_cg;
                    unsigned it  = cg_rank1prec(A, P, xk, B, Pj, x, j,
                                                Lambda[j-1], res_cg, tol_cg, maxit_cg);
                    #ifdef VERBOSE
                        std::cout << "precrank1als_sym: Sweep " << sweep << ", leaf "
                                  << j << ", CG required " << it
                                  << " iterations to reach "
                                  << res_cg << "\n";
                    #endif

                    /* Update x */
                    insert(x.tree(), xk, idx);
                    if (orthog) x.tree().orthogonalize();

                    break;
                }
            }

            switch (prec) {
                case 1: {
                    /* Full residual */
                    Ax = eval(A, x, Lambda, Lambda);
                    if (check_res) {
                        HTTree res = b.tree()-Ax.tree();
                        res.orthogonalize();
                        residual   = res.L2normorthogonal()/nrmb;
                            std::cout << "precrank1als_sym: Sweep " << sweep << ", leaf " << j
                                      << ", residual = " << residual << "\n";
                    }
                    break;
                }
                case 2: {
                    /* Full residual */
                    Ax = eval(A, x, Lambda, Lambda);
                    rank1prec(P, Ax, Lambda);
                    if (check_res) {
                        HTCoeff tmp;
                        tmp        = eval(A, x, Lambda, Lambda);
                        HTTree res = b.tree()-tmp.tree();
                        res.orthogonalize();
                        residual   = res.L2normorthogonal()/nrmb;
                            std::cout << "precrank1als_sym: Sweep " << sweep << ", leaf " << j
                                      << ", residual = " << residual << "\n";
                    }
                    break;
                }
            }
        }

        /* Check for stagnation */
        switch (prec) {
            case 1: {
                auto nrmx   = nrm2(xold);
                xold.tree() = x.tree()-xold.tree();
                T diff      = nrm2(xold)/nrmx;
                if (diff<=tol) {
                    return sweep;
                }
                break;
            }
            case 2: {
                auto nrmx   = nrm2(xold);
                xold.tree() = x.tree()-xold.tree();
                T diff      = nrm2(xold)/nrmx;
                if (diff<=tol) {
                    return sweep;
                }
                break;
            }
        }
    }

    std::cerr << "rank1als_sym: Reached max sweeps " << max_sweep << "\n";
    return max_sweep;
}

} // namespace lawa

#endif // LAWA_METHODS_ADAPTIVE_SOLVERS_RANK1ALS_TCC
